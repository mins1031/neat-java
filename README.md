# neat-java
> Java 개념 및 원리 정리. 우연히 개발에 필요한 개념들을 잘 정리해 깃헙에 올려주신 분을 보아 정리해본다.

## 1. Java의 대표적 특징
 * OOP(객체지향 프로그래밍)이다.
 * '가비지 컬렉션'에 의해 메모리가 자동 관리 된다.
 * '멀티 쓰레드'를 지원한다.
 * JVM위에서 동작하기 때문에 특정 OS에 종속적이지 않고 이식성이 좋으며 보안성이 좋다.
## 2. OOP(객체지향 프로그램)
 * 예전 '순차적,비구조적 프로그래밍' 방식은 규모가 점점 커지면 goto문을 남발해 코드의 흐름 파악에 너무 많은 힘을 들이는 경우가 많았다. 
 * 그래서 탄생한 것이 '절차적,구조적 프로그래밍이다'
   * => 반복될 가능성이 있는 것 들을 재사용이 가능한 함수로 만들어 사용하는 프로그래밍 방식이다.
   * 다만 너무 추상적인것이 단점이다. 예를 들어 회원에 해당 하는 필드를 구현해야 하는 경우 회원을 구현해야 하고 또 회원에 대한 다른 함수들을 따로 만들어 줘야하기에 코드가 더러워지고 비효율적으로 코딩할 가능성이 높아진다.
 * 따라서 위의 것들을 한번에 묶기 위한 패러다임이 바로 '객체지향 프로그래밍' OOP이다.
    * => 특정 클래스마다 필요한 필드를 만들고 getter/setter 필요하다면 함수도 넣어서 함께 관리 할 수 있다
    * **객체 내부에 필드와 함수가 같이 존재하는 것**이 중요한 점이다.
    * 이제 회원의 필드와 함수를 따로따로가 아닌 하나의 개체에 묶어서 저정 가능해졌다.
  **이렇게 가능한 모든 물리적, 논리적 요소를 객체로 만들려는 것이 '객체지향 프로그래밍'이다** 
  * **객체지향 프로그램의 장점**
    1) 프로그램 코드의 재사용성이 높고 개발 속도가 향상 된다.
    2) 프로그램을 간결하고 보기 용이하게 만든다
    3) 프로그램의 개발과 유지보수를 간편하게 만든다.
    4) 직관적인 코드 분석을 가능하게 한다.
    5) 객체지향 프로그래밍의 경우 하나의 문제를 해결하기 위해 데이터를 모아 놓은 객체를 활용한 프로그래밍을 지향함으로 응집력을 강하게 하고 클래스간 독립적으로 설계함으로써 결합도를 약하게 할 수 있다.
## 3. OOP의 특징
> OOP가 생겨나면서 크게 4가지의 특징을 갖추게 되었다. 이 4가지 특성을 잘 이해하고 구현해야 객체를 통한 효율적인 구현이 가능해진다.
  ### 추상화
  
  > 필요로 하는 속성이나 행동을 추출하는 작업
  **추상적인 개념에 의존하여 설계해야 유연함을 갖출 수 있다.**
  **즉 세부적인 사물들의 공통적이 특징을 파악한 후 하나의 집합으로 만들어 내는 것이 추상화 이다.**
  
  '''
  ex.  k3,아반떼,테슬라 모델3 는 모두 '자동차'라는 공통 특징이 있다. 
  자동차 라는 추상화 집합을 만들어 두고 자동차들이 가진 공통적이 특징들을 구현해 활용하는것.
  만약 자동차에 쏘렌토 같은 다른 차가 추가 될 수 있기 때문에 자동차라는 추상화를 구현 해놓으면 다른 코드는 수정할 필요 없이 추   가로 구현할 부분을 구현하는 것이 객체지향스럽다. 
  '''
  
  **즉 개체가 아닌 개체의 역할에 집중해서 구현해야 하는 것이다!!**
  ### 캡슐화
  
  > 높은 응집력과 낮은 결합도를 유지할 수 있도록 설계하는것
  =>  **한 곳에서 변화가 일어나도 다른 곳에 미치는 영향을 최소화 시키는것**을 말한다.= 객체가 내부적으로 기능을 어떻게 구현하는지 감추는 것!
  결합도가 낮게 만들어야 하는 이유는 **결합도란 어떤 기능을 실행할때 다른 클래스나 모듈에 얼마나 의존적인가를 나타내는 말이다.**. 즉 독립적으로 만들어진 객체간의 의존도를 초대한 낮게 만드는 것이 중요하다. 객체간의 의존도가 높아지면 굳이 객체 지향으로 설계하는 의미가 없어진다.
  ==> 캡슐화는 높은 응집력과 낮은 결합도를 갖게 하는 것을 **정보은닉**을 활용한다. 외부에서 접근할 필요가 없는 것들은 private으로 접근하지 못하게 제한을 두는것이다.
  ### 상속
  
  > 일반화 관계 라고도 하며 여러 개체들이 지닌 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립하는 과정
  상속은 또 다른 '캡슐화' 이다.
  **자식 클래스를 외부로부터 은닉하는 캡슐화의 일종**이라고 말할 수 있다.
  
  * 추상화에서 예시를 '자동차'로 들었는데 추가로 운전자 클래스가 있다고 하고 자동차의 자식클래스인 k3,아반떼 등은 캡슐화로 은닉해둔 상태이다.
  * 운전자 클래스의 관점으로는 구체적 자동차의 종류가 숨겨져 있지만 자동차의 종류가 운전에 큰 영향을 끼치진 않는다
  * 새로운 자동차들이 추가되어도 운전자 클래스는 영향을 받지 않는것이 중요하다 그래서 캡슐화를 통해 운전자클래스입장에서 확인할 수 없도록 구현하는 것이다.
  * 이처럼, 상속관계에서는 단순히 하나의 클래스 안에서 속성 및 연산들의 캡슐화에 한정되지 않는다. 즉, 자식클래스 자체를 캡슐화 하여 운전자 클래스 같은 외부에 은닉하는 것으로 확장되는 것이다.
  * 이렇게 자식클래스를 캡슐화 해두면 외부에선 이런 클래스들에 영향을 받지 않고 개발을 이어갈 수 있는 장점이 있다.
  ### 상속 재사용의 단점
   상속을 통한 재사용을 할 때 나타나는 단점도 존재한다.
      1) 부모 클래스의 변경이 어려워진다
        > 부모 클래스에 의존하는 자식클래스가 많을 때 부모 클래스의 변경이 필요하게 되면 이를 의존하는 자식클래스 들이 영향을 받게 된다.
      2) 불필요한 클래스가 증가할 수 있다.
        > 유사기능 확장시 필요이상의 불필요한 클래스를 만들어야 하는 상황이 발생할 수 있다.
      3) 상속이 잘못 사용될 수 있다.
 **해결책?**
 => 객체 조립, 컴포지션이라고 부르기도 한다.
 객체 조림은 **필드에서 다른 객체를 참조하는 방식으로 구현 된다.** 
 상속에 비해 런타임 구조가 복잡하고 구현이 어려운 단점이존재하지만 변경시 유연함을 확보하는데 장점이 매우 크다
 따라서 같은 종류가 아닌 클래스를 상속하고 싶을 때는 객체 조립을 우선적으로 적용하는 것이 좋다.
 
 ### 다형성
 
 > 서로다른 클래스의 객체가 같은 메시지를 받았을 떄 각자의 방식으로 동작하는 능력

 * 객체지향의 핵심. 다형성은 상속과 함깨 활용할때 큰힘을 발휘한다. 코드를 간결하게 해주고, 유연함을 갖추게 해준다. 
 * 즉 **부모클래스의 메서드를 자식클래스가 오버라이딩 해서 자신의 역할에 맞게 활용하는 것이 다형성이다.**
 * 다형성을 사용하면 하나의 타입으로 다양한 실행결과를 얻을 수 있어 객체를 **부품화**해 유지보수를 용이하게 한다..

## 4. 객체 지향 설계 과정
  * 제공해야 할 기능을 찾고 세분화한다. 그리고 그 기능을 알맞은 객체에 할당한다.
  * 기능을 구현하는데 필요한 데이터를 객체에 추가한다.
  * 그 데이터를 이용하는 기능을 넣는다.
  * 기능은 최대한 캡술화하여 구현한다.
  * 객체간에 어떻게 메서드 요청을 주고받을지 결정한다.
 
## 객체지향 설계 원칙
SOLID라고 하는 5가지 설계 원칙이 존재한다
  ### SPR 단일 책임 원칙
   * 하나의 클래스는 하나의 책임만 가져야 한다
   * 하나의 책임이라는 것은 모호하다
     * 클 수도 있고, 작을 수도 있다
     * 문맥과 상황에 따라 다르다.
   * 중요한 기준은 변경이다. 변경이 있을때 파급 효과가 적으면 단일책임 원칙을 잘 따른것
   * 개인적으로 클래스뿐만
   * 아니라 메서드도 같은 선상에서 바라봐야 한다고 생각한다.
  ### OCP 개방-폐쇄 원칙
   * 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
   * 다형성을 잘 활용해서 설계해야 한다.
   * 즉 기능을 변경하거나 확장할 수 있으면서 그 기능을 사용하는 코드는 수정하지 않아야 된다.
   * 다만 다형성을 사용해도 OCP를 웬만하면 지키기 힘들다. 그래서 별로 객체 생성, 연관관계 맺어주는 설정자(=Spring)이 필요하다
  ### LSP 리스코프 치환 원칙
   * 프로그램의 객체는 프로그램의 정확성을 꺠뜨리지 않으면서 하위 타입의 인스턴스로 바꿀수 있어야 한다.
   * 쉽게 말해서 자동차 인터페이스와 k3 구현체가 있다. 구현체의 엑셀기능은 앞으로 가라는 기능이다. 이 기능이 뒤로가게 할 수도 있지만 이것은 기존기능을 위배하는 기능이다.
   * 즉 인터페이스를 구현한 구현체를 믿고 사용하려면 이 원칙이 지켜져야 한다는 이야기 이다.
  ### ISP 인터페이스 분리 원칙
   * 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.
   * 자동차 인터페이스 -> 운전,정비 인터페이스로 분리
   * 사용자 클라이언트 -> 운전자,정비사 클라이언트로 분리
   * 이렇게 분리해 놓으면 정비사 클라이언트가 변해도 운전자 클라이언트에 영향을 주지 않는다(내용,기능이 변하지 않는다) 
   * 인터페이스가 명확해지고 대체 가능성이 높아진다.
  ### DIP 의존역전 원칙
   * 프로그래머는 추상화에 의존해야지 구체화에 의존하면 안된다. 의존성 주입은 이 원칙을 따르는 방법중 하나다.
   * 쉽게 클래스에 의존하지 말고 인터페이스에 의존하라는 뜻이다.
   * 위에서 이야기한 **역할에 의존하게 해야한다는 것과 같다**. 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다. 구현체에 의존하게 되면 변경이 아주 어려워 진다.
## 5. JVM (자바 가상 머신)
 JVM은 다른 프로그램을 실행시키는 것이 목적이다. 갖춘기능으로는 크게 2가지로 말할 수 있다
 1. 자바 프로그램이 어느기기나 운영체제에서도 실행될 수 있도록 하는것.
 2. 프로그램 메모리를 관리하고 최적화 하는것.
 **자바 어플리케이션을 클래스 로더를 통해 읽어 들이고 자바 API와 함꼐 실행하는 역할, 자바와 OS사이에서 중개자 역할을 수행하며 OS에 제한되지 않고 재사용을 가능하게 한다.**
 
 ### 5-1 자바 컴파일 과정
 > 자바는 OS에 독립적인 특징을 가지고 있다. 운영체제 위에서 메모리를 할당받아 동작하는 JVM 덕분인데 어떤 기능,어떤 원리로 이렇게 OS에 독립적일 수 일까?
 <img src = "https://camo.githubusercontent.com/af3d43865302485f944cbc6a7a7c3fcb27d3227320e5bf0b2cd8013d76507c07/687474703a2f2f7463707363686f6f6c2e636f6d2f6c656374757265732f696d675f6a6176615f70726f6772616d6d696e672e706e67" />
 
 <img src = "https://camo.githubusercontent.com/9ada78092a3d1fd3e81574ad2b48baf0db97baced4d4a3e0eca1b0d014152ae4/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f393931443036344235414539393944353132" />
 
  #### 자바 컴파일 순서
   1) 자바 소스 코드(.java)를 작성.
   2) 자바 컴파일러가 자바 소스파일을 컴파일한다. 이때 컴파일후 결과 파일을 '자바 바이트 코드'(.class)파일로 아직 컴퓨터가 읽을수 없고 JVM이 읽을 수 있는 코드이다.
   3) 컴파일된 바이트 코드를 JVM의 '클래스로더'에게 전달한다.
   4) 클래스로더는 동적로딩을통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역즉 JVM의 메모리에 올린다. 
   5) 실행엔진은 JVM메모리에 올라온 바이트 코드들은 명령어 단위로 하나씩 가져와서 실행한다. 이떄 실행엔진은 두가지방식으로 변경한다.
     * 인터프리터 : 바이트코드 명령어를 하나씩 읽어서 해석하고 실행한다. 하나하나의 실행은 빠르나 전체적인 실행 속도가 느리다는 단점이 있다
     * JIT 컴파일러 : 인터프리터의 단점을 보완하기 위해 도입된 방식으로 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 이후에는 해당 메서드를 더이상 인터프리팅 하지 않고 바이너리 코드로 직접 실행하는 방식, 바이트코드 전체가 컴파일된 바이너리 코드를 실행하는 것이기 때문에 전체적 실행속도는 인터프리팅 방식보다 빠르다.
 
 ### 5-2 JVM 실행과정
   1) 프로그램이 실행되면 JVM은 OS로부터 프로그램이 필요로하는 메모리를 할당 받고 이 메모리를 용도에 따라 여러 영역으로 나누어 관리함.
   2) 자바 컴파일러(JAVAC)가 자바 소스코드를 읽고 자바 바이트코드(.class)로 변환 시킴 
   3) 컴파일된 class파일들을 클래스 로더로 전달하고 클래스 로더가 JVM의 메모리 영역으로 로딩한다. + JVM은 런타임시에 처음으로 클래스를 참조할때 클래스를 로드하고 메모리 영역에 배치시키는데 이 동적로딩을 해주는것이 **클래스로더**이다.
   4) 로딩된 class파일들은 Execution engine을 통해 해석됨
   5) 해석된 바이트 코드는 메모리 영역에 배치되어 실질적인 수행이 이루어진다. 이러한 실행과정 속 JVM은 필요에 따라 스레드 동기화나 가비지 컬렉션 같은 메모리 관리 작업을 수행한다.
<img src = "https://camo.githubusercontent.com/ffc29b7d559030c287454c8d784d8d2f80e8e46cfe4d36069f27e749ee2cd76a/68747470733a2f2f692e696d6775722e636f6d2f5679314a4331622e706e67" />

 #### Runtime Data area 
 JVM이 운영체제 위에서 실행하면 할당 받는 메모리 영역이다. PC레지스터, JVM스택, 네이티브 메서드 스택,힙,메서드  영역 총 5가지 영역으로 나누어진다. 이 중 **힙과 메서드 영역은 모든 스레드가 공유해서 사용한다.**
  * PC 레지스터 : 스레드가 어떤 명령어로 실행되어야 할지 기록하는 붑ㄴ(JVM 명령의 주소를 가진다.)
  * 스택 area : 지역변수 , 매개변수, 메서드 정보, 임시 데이터 등을 저장한다.
  * 네이티브 메서드 스택 : 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역
  * 힙 : 런타임에 동적으로 할당되는 데이터가 저장되는 영역. 객체나 배열 생성이 여기에 해당한다. (또한 힙에 할당된 데이터들은 가비지 컬렉터의 대상이 된다. JVM성능 이슈에서 가장 많이 언급되는 공간이다.)
  * 메서드 영역 : JVM이 시작될때 생성되고 JVM이 읽은 각각의 클래스와 인터페이스에 대한 런타임 상수 풀,클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보같은 필드 정보와 메소드의 이름, 리턴 타입, 파라미터, 접근 제어자 정보같은 메소드 정보, Type정보(Interface인지 class인지), Constant Pool(상수 풀 : 문자 상수, 타입, 필드, 객체 참조가 저장됨), static 변수, final class 변수등이 생성되는 영역이다.
  + 메모리 상수풀 영역 : 힙 영역에서 생성되고 자바 프로세스 종료까지 계속 유지된는 메모리 영역. 기본적으로 JVM에서 관리하고 각 클래스, 인터페이스 상수, 메서드 필드와 모든 레퍼런스가 담겨있디. 런타임 상수 풀의 역할은 이미 있는 메소드나 필드의 참조를 통해 중복을 막음.

#### 가비지 컬렉션
 * 자바 이전에는 프로그래머가 모든 프로그램 메모리를 관리했다. 하지만 자바에서는 JVM이 프로그램 메모리를 관리한다.
 * JVM은 가비지 컬렉션이라는 프로세스를 통해 메모리를 관리한다. 가비지 컬렉션은 자바 프로그램에서 사용되지 않는 메모리를 지속적으로 찾아 제거하는 역할을 한다.
 * 실행순서 : 참조되지 않은 객체들을 탐색후 삭제 -> 삭제된 객체의 메모리를 반환 -> 힙 메모리 재사용
